import os
import re
from collections import defaultdict

def parse_opcode_lines(description_lines):
    opcode_dict = defaultdict(list)
    operand_dict = defaultdict(dict)
    operand_name = None
    opcode_lines = False
    seen_opcodes = dict()
    for line in description_lines:
        line = line.split(';', 1)[0].strip()
        if re.match(r'^operand \w+$', line):
            operand_name = line.split()[1]
            continue
        if line.lower() == 'instructions':
            opcode_lines = True
            continue
        if not line or line.startswith(';'):
            continue
        if operand_name:
            if line == 'endoperand':
                operand_name = None
                continue
            parts = line.split()
            operand_dict[operand_name][parts[1]] = parts[0]
        if opcode_lines:
            parts = line.split()
            opcode, disassembly = parts[0], " ".join(parts[1:])
            if not re.match(r'^[0-9a-fA-F]', opcode):
                continue
            if opcode in seen_opcodes:
                seen_opcodes[opcode] += 1
                method_name_suffix = f"_{seen_opcodes[opcode]}"
            else:
                seen_opcodes[opcode] = 1
                method_name_suffix = ""
            mnemonic_name = re.match(r'\w+', disassembly).group(0)
            method_name = f"op{mnemonic_name.capitalize()}_{opcode}{method_name_suffix}"
            op_hex_prefix = re.match(r'[0-9a-fA-F]+', opcode)
            if op_hex_prefix:
                hex_prefix = op_hex_prefix.group(0)
                opcode_dict[hex_prefix].append((opcode, disassembly, mnemonic_name, method_name))
    for hex_prefix, mnemonic_tuple in opcode_dict.items():
        if len(mnemonic_tuple) > 1:
            print(f"Conflict: {mnemonic_tuple}")
    return opcode_dict, operand_dict

def create_nested_tables(opcode_dict):
    root_table = [None] * 16
    tables = {}

    def create_table(suffix):
        table = [None] * 16
        tables[suffix] = table
        return table

    def add_to_table_list(table, hex_key, opcode, mnemonic, method, suffix):
        if len(hex_key) == 0:
            return
        nibble = int(hex_key[0], 16)
        new_suffix = suffix + hex_key[0]
        if suffix == '808':
            pass
        if len(hex_key) == 1:
            if table[nibble] is None:
                table[nibble] = (opcode, mnemonic, disassembly, method, [])
            elif isinstance(table[nibble], tuple):
                table[nibble][4].append((opcode, mnemonic, disassembly, method))
        else:
            if isinstance(table[nibble], tuple):
                return
            elif table[nibble] is None:
                table[nibble] = create_table(new_suffix)
            add_to_table_list(table[nibble], hex_key[1:], opcode, mnemonic, method_name, new_suffix)

    def add_to_table(table, hex_key, opcode, mnemonic, method, suffix):
        if len(hex_key) == 0:
            return
        nibble = int(hex_key[0], 16)
        new_suffix = suffix + hex_key[0]
        if len(hex_key) == 1:
            if table[nibble] is None:
                table[nibble] = (opcode, mnemonic, disassembly, method)
        else:
            if isinstance(table[nibble], tuple):
                return
            elif table[nibble] is None:
                table[nibble] = create_table(new_suffix)
            add_to_table(table[nibble], hex_key[1:], opcode, mnemonic, method_name, new_suffix)

    for hex_prefix, mnemonic_tuple in opcode_dict.items():
        for opcode_pattern, disassembly, mnemonic_name, method_name in mnemonic_tuple:
            add_to_table_list(root_table, hex_prefix, opcode_pattern, mnemonic_name, method_name, "")

    return root_table, tables

def generate_cpp_header(root_table, tables, opcode_dict, operands):
    cpp_code = """//---------------------------------------------------------------------------------------
// AUTOGENERATED BY """ + os.path.basename(__file__)+ """
//---------------------------------------------------------------------------------------
#pragma once

#include <array>
#include <cstdint>
#include <string>
#include <vector>
#include <iostream>

class HpSaturnBase
{
public:
    constexpr static uint32_t ADDRESS_SPACE = 0x100000;
    constexpr static uint32_t RAM_OFFSET = 0x70000;
    constexpr static uint32_t RAM_END = 0x80000;
    HpSaturnBase();
    ~HpSaturnBase() = default;
    void loadData(uint32_t address, const std::vector<uint8_t>& data)
    {
        std::copy(data.begin(), data.end(), _ram.begin() + address/2);
    }
    unsigned readNibble(const uint32_t address) const
    {
        //constexpr char hex[] = "0123456789abcdef";
        const auto nibble = address & 1 ? _ram[address>>1] >> 4 : _ram[address>>1] & 0xf;
        //std::cout << hex[nibble];
        return nibble;
    }
    uint64_t readNibbles(int n, uint32_t& address) const
    {
        uint64_t result = 0;
        for (uint32_t i = 0; i < n; ++i) {
            result |= readNibble(address++) << (i*4);
        }
        return result;
    }
    template <int N>
    uint64_t readNibbles(uint32_t& address) const
    {
        uint64_t result = 0;
        for (uint32_t i = 0; i < N; ++i) {
            result |= readNibble(address++) << (i*4);
        }
        return result;
    }
    template <int N>
    uint64_t readNibbles()
    {
        return readNibbles<N>(_rPC);
    }
    void handleOpcode();
    std::string readOperands(std::string_view opcodePattern, uint32_t& address, std::array<std::pair<std::string_view, uint64_t>, 4>& operands) const;
    std::pair<std::string,std::string> disassembleOpcode(uint32_t& address) const;
"""

    # Generate methods for each opcode endpoint, ordered alphabetically
    methods = []
    for hex_prefix, mnemonic_tuple in opcode_dict.items():
        for opcode, disassembly, mnemonic, method_name in mnemonic_tuple:
            # Extract the mnemonic and opcode
            method_code = f"    void {method_name}();\n"
            methods.append((method_name, method_code))

    # Sort methods alphabetically by name
    methods.sort(key=lambda x: x[0])
    for _, method_code in methods:
        cpp_code += method_code

    cpp_code += """
protected:
    uint64_t _rA{};
    uint64_t _rB{};
    uint64_t _rC{};
    uint64_t _rD{};
    std::array<uint64_t, 5> _rR{};
    std::array<uint32_t, 8> _rRSTK{};
    uint16_t _rIN{};   // 10 bit
    uint16_t _rOUT{};  // 10 bit
    uint32_t _rPC{};
    uint32_t _rD0{};
    uint32_t _rD1{};
    uint16_t _rST{};
    uint8_t _rP{};
    uint8_t _rHS{};
    bool _rCarry{false};
    std::vector<uint8_t> _ram;
};
"""

    return cpp_code

def debug_lc(v,e):
    print(f"<<<{v}:{e}>>>")
    return True if v == e else False

def generate_cpp_source(root_table, tables, opcode_dict, operands):
    cpp_code = """//---------------------------------------------------------------------------------------
// AUTOGENERATED BY """ + os.path.basename(__file__)+ """
//---------------------------------------------------------------------------------------
#include "hpsaturnbase.hpp"
#include <fmt/format.h>
#include <cstring>
#include <charconv>
#include <iostream>

HpSaturnBase::HpSaturnBase()
: _ram(ADDRESS_SPACE/2, 0)
{
}

"""
    # Generate methods for each opcode endpoint, ordered alphabetically
    methods = []
    for hex_prefix, mnemonic_tuple in opcode_dict.items():
        for opcode, disassembly, mnemonic, method_name in mnemonic_tuple:
            # Extract the mnemonic and opcode
            method_code = f"// {disassembly}\nvoid HpSaturnBase::{method_name}()\n{{\n"

            # Check for sequences of equal non-hex letters after hex prefix
            remainder = opcode[len(hex_prefix):]
            idx = 0
            while idx < len(remainder):
                if remainder[idx].isalpha():
                    start_idx = idx
                    while idx < len(remainder) and remainder[idx] == remainder[start_idx]:
                        idx += 1
                    length = idx - start_idx
                    var_name = remainder[start_idx:start_idx + length]
                    method_code += f"    auto {var_name} = readNibbles<{length}>();\n"
                else:
                    idx += 1

            method_code += "}\n\n"
            methods.append((method_name, method_code))

    # Sort methods alphabetically by name
    methods.sort(key=lambda x: x[0])
    for _, method_code in methods:
        cpp_code += method_code


    # Sort tables by length of table name, longest to shortest
    sorted_tables = sorted(tables.items(), key=lambda x: len(x[0]), reverse=True)

    cpp_code += """
struct OpcodeEntry {
    const char* opcode;
    const char* mnemonic;
    const OpcodeEntry* next;
    void (HpSaturnBase::*handler)();
};
"""
    # Generate all tables
    table_code = ""
    conflict_code = ""
    conflict_idx = 0
    for suffix, table in sorted_tables:
        table_code += f"\nstatic const OpcodeEntry table_{suffix}[16] = {{\n"
        for entry in table:
            if entry is None:
                table_code += "    { nullptr, nullptr, nullptr, nullptr },\n"
            elif isinstance(entry, tuple):
                opcode, mnemonic, disassembly, method, others = entry
                handler_name = f"&HpSaturnBase::{method}"
                if len(others):
                    first_idx = conflict_idx
                    num_others = len(others)
                    for opcode_c, mnemonic_c, disassembly_c, method_c in others:
                        num_others -= 1
                        conflict_code += f"    {{ \"{opcode_c}\", \"{disassembly_c}\", {'&conflict_table['+str(conflict_idx+1)+']' if num_others>0 else 'nullptr'}, &HpSaturnBase::{method_c} }},\n"
                        conflict_idx += 1
                    table_code += f"    {{ \"{opcode}\", \"{disassembly}\", &conflict_table[{first_idx}], {handler_name} }}, // {others}\n"
                else:
                    table_code += f"    {{ \"{opcode}\", \"{disassembly}\", nullptr, {handler_name} }},\n"
            else:
                print(f"###{[k for k, v in tables.items() if v == entry]}###")
                next_table_suffix = [k for k, v in tables.items() if debug_lc(v,entry)][0]
                table_code += f"    {{ nullptr, nullptr, table_{next_table_suffix}, nullptr }},\n"
        table_code += "};\n"

    # Generate the root table last
    table_code += "\n\nstatic const OpcodeEntry root_table[16] = {\n"
    for entry in root_table:
        if entry is None:
            table_code += "    { nullptr, nullptr, nullptr, nullptr },\n"
        elif isinstance(entry, tuple):
            opcode, mnemonic, disassembly, method, others = entry
            handler_name = f"&HpSaturnBase::{method}"
            if len(others):
                first_idx = conflict_idx
                num_others = len(others)
                for opcode_c, mnemonic_c, disassembly_c, method_c in others:
                    num_others -= 1
                    conflict_code += f"    {{ \"{opcode_c}\", \"{disassembly_c}\", {'&conflict_table['+str(conflict_idx+1)+']' if num_others>0 else 'nullptr'}, &HpSaturnBase::{method_c} }},\n"
                    conflict_idx += 1
                table_code += f"    {{ \"{opcode}\", \"{disassembly}\", &conflict_table[{first_idx}], {handler_name} }}, // {others}\n"
            else:
                table_code += f"    {{ \"{opcode}\", \"{disassembly}\", nullptr, {handler_name} }},\n"
        else:
            table_suffix = [k for k, v in tables.items() if v == entry][0]
            table_code += f"    {{ nullptr, nullptr, table_{table_suffix}, nullptr }},\n"

    table_code += "};\n"

    cpp_code += f"\nstatic const OpcodeEntry conflict_table[{conflict_idx}] = {{\n{conflict_code}}};\n"
    cpp_code += table_code

    for name, values in operands.items():
        cpp_code += f"\nconst char* operand{name.capitalize()}[{len(values)}] = {{"
        for idx, text in values.items():
            if idx != "0":
                cpp_code += ", "
            cpp_code += f"\"{text}\""
        cpp_code +="};\n"

    cpp_code += """
void HpSaturnBase::handleOpcode()
{
    const OpcodeEntry* current = &root_table[readNibbles<1>()];
    while (current != nullptr) {
        if (current->handler != nullptr) {
            (this->*current->handler)();
            return;
        }
        if (current->next == nullptr) {
            std::cerr << "Error: Invalid opcode" << std::endl;
            return;
        }
        current = &current->next[readNibbles<1>()];
    }
    std::cerr << "Error: Invalid opcode" << std::endl;
}

class Operands
{
public:
    Operands(const HpSaturnBase& saturn, const std::string_view opcodePattern, uint32_t& address)
    {
        constexpr char hexDigits[] = "0123456789abcdef";
        auto outIter = operands.begin();
        auto iter = opcodePattern.begin();
        while (iter != opcodePattern.end() && std::isxdigit(*iter))
            ++iter;
        while (iter != opcodePattern.end()) {
            auto iter2 = iter;
            while (iter2 != opcodePattern.end() && *iter == *iter2) {
                ++iter2;
            }
            const auto size = static_cast<int>(iter2 - iter);
            uint64_t operand = 0;
            for (size_t i = 0; i < size; ++i) {
                const auto nibble = saturn.readNibble(address++);
                operand |= nibble << (i*4);
                hexOperands += hexDigits[nibble];
            }
            *outIter++ = {std::string_view(iter, size), operand};
            numberOfOperands++;
            iter = iter2;
        }
        while (outIter != operands.end()) {
            *outIter++ = {"",0};
        }
    }
    uint64_t getOperand(const std::string_view name) const
    {
        for (const auto& [opName, operand] : operands) {
            if (opName == name) {
                return operand;
            }
        }
        return 0;
    }
    std::string formatOperands(const std::string_view disassembly) const
    {
        std::string result;
        auto iter = disassembly.begin();
        while (iter != disassembly.end()) {
            if (*iter != '<')
                result += *iter++;
            else {
                auto iter2 = ++iter;
                while (iter2 != disassembly.end() && *iter == *iter2) {
                    ++iter2;
                }
                auto operand = getOperand({iter, iter2});
                iter = iter2 + 1; // skip equal
                switch (*iter) {
                    case 'n': {
                        // nzconst
                        iter += 2;
                        [[fallthrough]];
                    }
                    case 'c': {
                        // const(n)
                        iter += 6;
                        int size = 0;
                        auto [ptr, ec] = std::from_chars(&(*iter), &(*(iter + 2)), size);
                        result += fmt::format("#{:0{}x}", operand, size>>2);
                        iter += size>=10 ? 4 : 3;
                        break;
                    }
                    default:
                        break;
                }
            }
        }
        return result;
    }
    size_t numberOfOperands{0};
    std::string hexOperands;
    std::array<std::pair<std::string_view, uint64_t>, 4> operands;
};


std::pair<std::string, std::string> HpSaturnBase::disassembleOpcode(uint32_t& address) const
{
    uint32_t opcode = readNibbles<1>(address);
    size_t length = 1;
    const OpcodeEntry* current = &root_table[opcode];
    while (current != nullptr) {
        if (current->mnemonic != nullptr) {
            auto size = std::strlen(current->opcode);
            //opcode = opcode << (size - length) * 4 | readNibbles(size - length, address);
            // address += std::strlen(current->opcode) - length;
            Operands operands(*this, current->opcode, address);
            return {fmt::format("{:0{}x}{}", opcode, length, operands.hexOperands), fmt::format("{}{}", operands.formatOperands(current->mnemonic), current->next ? "?" : "")};
        }
        if (current->next == nullptr) {
            std::cerr << "Error: Invalid opcode" << std::endl;
            return {fmt::format("{:0{}x}", opcode, length), ""};
        }
        auto nibble = readNibbles<1>(address);
        ++length;
        opcode = (opcode << 4) | nibble;
        current = &current->next[nibble];
    }
    std::cerr << "Error: Invalid opcode" << std::endl;
    return {fmt::format("{:0{}x}", opcode, length), ""};
}
"""
    return cpp_code

def main():
    with open('/home/schuemann/attic/dev/c8/cadmium/instr.tab', 'r') as f:
        description_lines = f.readlines()

    opcode_dict, operand_dict = parse_opcode_lines(description_lines)
    root_table, tables = create_nested_tables(opcode_dict)
    cpp_header = generate_cpp_header(root_table, tables, opcode_dict, operand_dict)
    with open('hpsaturnbase_x.hpp', 'w') as f:
        f.write(cpp_header)
    cpp_source = generate_cpp_source(root_table, tables, opcode_dict, operand_dict)
    with open('hpsaturnbase_x.cpp', 'w') as f:
        f.write(cpp_source)

if __name__ == "__main__":
    main()
